<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Dulcimer: Dulcimer</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Dulcimer</h1>
<p>
<h2><a class="anchor" name="sec_intro">
Introduction</a></h2>
A computer keyboard can be a very personal utensil. Especially if it is an extraordinary well built one, like for example the IBM Model M. The Model M design dates back to 1984, but it still has many fans even nowadays. It came with the usual keyboard connectors. First the old 5-pin one, later a PS/2 plug. Unfortunately is that, at least to my knowledge, they never released a version with USB.<p>
A friend of mine knew that I already had built other USB-devices, and one of them even acted as a keyboard (it isn't really a keyboard, but that's a different story... ;-) ). He is a big fan of the Model M, so he asked if I could put new life in one of his old keyboards, which had a broken circuit inside. And this is the result...<h3><a class="anchor" name="sec_technique">
Hard- and Software</a></h3>
The main part of a computer keyboard circuit is the key matrix. You can imagine it as a number of keys, placed on a raster of horizontal (rows) and vertical (columns) wires. In the case of a Model M keyboard, we have a matrix of 8x16 lines. Eight columns in 16 rows, or the other way around, depending on how you look at it. Each key is connected to one column and one row. If you press the key, it will connect the column and the row on it's crossing of the lines.<p>
Connected to this matrix is a keyboard controller. That's a chip with a number of I/O-lines to detect the state of the matrix, and on the other side an interface that enables it to talk to the computer. Oh, and not to forget: it also has three output lines to drive the LEDs for Num-, Caps- and Scroll-lock.<p>
What I did in this project is, that I dumped the keyboard controller chip and its circuit, and replaced it by an ATmega32 and my own circuit. The ATmega scans the matrix for keyboard activity, controls the LEDs and talks to the computer.<p>
For further convenience, I added a boot-loader. With that, it is possible to update the keyboard's firmware without disassembling it, and without the need for a dedicated programmer.<h3><a class="anchor" name="sec_hardware">
Other hardware?</a></h3>
As mentioned, the controller in this project is just connected to an ordinary keyboard matrix. You can find this kind of matrix in all kinds of keyboards, from key-telephones over good old hardware like the Commodore C=64 or the Schneider CPC, keyboards with non-PC-connectors like those made by Sun, to modern hardware that could need a few more features.<p>
Till now, I just made a PCB layout for the IBM Model M, but I intend to modify at least a Sun keyboard. In order to do that, I expect having to refactor the key-scanning, since the key-matrix is not 16x8. The positions of the keys on the matrix will be different, I'll have to re-engineer that. And of course, I'll have to make another PCB.<h3><a class="anchor" name="sec_features">
Features</a></h3>
At the moment, the keyboard should be able to do everything that the average off-the-shelf-keyboard can do. But there are many features that are possible, regarding the fact that the ATmega32 is absolutely bored till now. You can think of 'magic keystrokes' that turn some hidden features on or off, like for example:<ul>
<li>send complete phrases on one keystroke</li><li>'autofire' feature on keys that don't repeat normally, for example Alt+F4</li><li>change keyboard layout without reconfiguring the computer</li><li>turn bouncing keys on or off, to annoy other people using your computer</li><li>random caps lock function</li><li>use arrow keys as mouse, without having to include a special driver in the OS.</li></ul>
<p>
With a little tweaking on the hardware side, there should be even more possibilities:<ul>
<li>turn the oldtimer-keyboard into a supermodern wireless bluetooth one</li><li>implement keylogger-funktionality, using for example an SD-card</li><li>include an USB-hub into the keyboard</li></ul>
<p>
If you are just a little like me, it won't take you much brainstorming to come up with own useful -- or even better: useless -- ideas. ;-)<h2><a class="anchor" name="sec_install">
Building and installing</a></h2>
Both, the bootloader and firmware are simply built with "make". You may need to customize both makefiles to fit to your system. If you don't want to add new features, you don't need to build the software yourself. You can use the hex-files included in this package.<h3><a class="anchor" name="sec_boot">
Bootloader</a></h3>
I used the USBaspLoader from Objective Development, the same guys that wrote the AVR-USB-driver: <a href="http://www.obdev.at/products/avrusb/usbasploader.html">http://www.obdev.at/products/avrusb/usbasploader.html</a><p>
The reason why I chose this over some other available USB-bootloaders is, that this one emulates a common ISP-programmer that is supported by avrdude. In this way, the same program can be used to program the chip that is used without a bootloader.<p>
To prepare the ATmega32, you have to connect it to your computer with the ISP-programmer of your choice and modify the makefile according to that. Then you enter the bootloader-directory and enter the following line:<p>
<div class="fragment"><pre class="fragment"> make fuse &amp;&amp; make flash &amp;&amp; make lock
</pre></div><p>
With 'fuse' you prepare the fuse-bits of your AVR, 'flash' transfers the bootloader to the device and 'lock' prevents you from overwriting the bootloader. Don't fear the locking: you can always reset it with your ordinary programmer. In fact, it is disabled in the moment you use your ordinary programmer to reflash the device, even without any special parameters. The locking only affects the bootloader behavior.<p>
Afterwards you can put the programmer back into the toolbox, you won't need it from here on.<p>
When you plug in the device while holding the minus-key on the number-keypad pressed, the keyboard indicates that it would like to get a new firmware by showing a running light on the LEDs. That firmware will be flashed over the normal USB-cable that the keyboard is connected with.<h3><a class="anchor" name="sec_fw">
Firmware</a></h3>
If you intend to recompile the firmware yourself, you will need avr-gcc and avr-libc (a C-library for the AVR controller). Please read the instructions at <a href="http://www.nongnu.org/avr-libc/user-manual/install_tools.html">http://www.nongnu.org/avr-libc/user-manual/install_tools.html</a> for how to install the GNU toolchain (avr-gcc, assembler, linker etc.) and avr-libc.<p>
Once you have the GNU toolchain for AVR microcontrollers installed, you can run "make" in the subdirectory "firmware".<p>
Afterwards -- or if you decided not to compile the firmware yourself -- you can flash it to the device:<p>
<div class="fragment"><pre class="fragment"> make program
</pre></div><p>
Remember that you have to start the bootloader at first: unplug the keyboard, hold the minus-key on the number-keypad pressed and replug it. If the modified keyboard is the only one within reach: good luck! ;-)<h2><a class="anchor" name="sec_usage">
Usage</a></h2>
Connect the keyboard to the USB-port. All LED should flash up to indicate that the device is initialized.<p>
Then you can use the keyboard as always. If additional features get implemented, you will be able to use them in their respective ways.<h2><a class="anchor" name="sec_drawbacks">
Drawbacks</a></h2>
I don't know if and how keyboard manufacturers face the problem of ghost keys, I didn't take special measurements for this. I hope that the engineers at IBM distributed the keys on the matrix in a way that minimizes this problem. Don't misunderstand: I haven't experienced that on this keyboard, but I know that it's a common problem on key-matrixes.<h2><a class="anchor" name="sec_files">
Files in the distribution</a></h2>
<ul>
<li><em>Readme.txt:</em> Documentation, created from the htmldoc-directory.</li><li><em>firmware:</em> Source code of the controller firmware.</li><li><em>firmware/usbdrv</em>: USB driver -- See Readme.txt in this directory for info.</li><li><em>bootloader:</em> The USBaspLoader, properly configured for this project. I only modified the <a class="el" href="bootloaderconfig_8h.html" title="This file (together with some settings in Makefile) configures the boot loader according...">bootloaderconfig.h</a> and the Makefile.</li><li><em>USBaspLoader.2008-02-05.tar.gz</em>: The unmodified bootloader sources, for reference.</li><li><em>circuit:</em> Circuit diagrams in PDF and KiCAD format. KiCAD is a free schematic- and layout-tool, you can learn more about it at its homepage: <a href="http://www.lis.inpg.fr/realise_au_lis/kicad/">http://www.lis.inpg.fr/realise_au_lis/kicad/</a></li><li><em>License.txt:</em> Public license for all contents of this project, except for the USB driver. Look in firmware/usbdrv/License.txt for further info.</li><li><em>Changelog.txt:</em> Logfile documenting changes in soft-, firm- and hardware.</li><li><em>refman.pdf:</em> Full documentation of the software.</li></ul>
<h2><a class="anchor" name="sec_thanks">
Thanks!</a></h2>
I'd like to thank <b>Objective Development</b> for the possibility to use their driver for my project. In fact, this project wouldn't exist without the driver.<p>
And of course I'd like to thank that friend of mine -- I doubt that he'd like to read his name in this place, I'll put it in if he wants me to -- that gave me the idea for this project.<h2><a class="anchor" name="sec_license">
About the license</a></h2>
My work - all contents except for the USB driver - is licensed under the GNU General Public License (GPL). A copy of the GPL is included in License.txt. The driver itself is licensed under a special license by Objective Development. See firmware/usbdrv/License.txt for further info.<p>
<b>(c) 2008 by Ronald Schaten - <a href="http://www.schatenseite.de">http://www.schatenseite.de</a></b> <hr size="1"><address style="text-align: right;"><small>Generated on Sat Jul 12 22:27:14 2008 for Dulcimer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
